# 15. 三数之和

## 题目地址

[三数之和](https://leetcode-cn.com/problems/3sum/)

## 方法：排序 + 双指针

### 思路

本题的难点在于如何**去除重复元素**。如果采用最暴力的做法，用三重遍历找出所有的组合，然后使用哈希表去重，时间和空间的复杂度都很高。

如果我们保证每次遍历的数字都是不同的数字，那么结果中自然不会出现重复解。我们可以采用排序的方法，每次遍历的时候，如果当前的数字和前一个数字相等，说明我们已经遍历过这个数字了，可以不用管了。

第二重和第三重循环可以并列求解。采用双指针的做法，让第二个元素递增遍历，第三个元素递减遍历。

具体算法如下：
* 把数组按照从小到大的顺序排序；
* 遍历数组：
   - 如果是重复数（和前一个数相等），直接跳过；
   - 令 `l = i + 1, r = n - 1`，当`l < r`时，执行循环：
     -  如果`nums[i] + nums[l] + nums[r] == 0`，判断左边界 `j`是否重复（如果左边界重复，那么右边界也一定重复）。如果不重复，把组合添加到结果中。同时右移左边界，左移右边界；
     -  如果和小于0，右移左边界；
     -  如果和大于0，左移右边界。

### 代码

```Golang
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    result := [][]int {}
    size := len(nums)
    for i := 0; i < size; i++ {
        if i == 0 || nums[i] != nums[i - 1] { // 保证每个枚举的i都是不同的
            j, k := i + 1, size - 1
            for j < k {
                sum := nums[i] + nums[j] + nums[k]
                if sum < 0 {
                    j++
                } else if sum > 0 {
                    k--
                } else {
                    if (j == i + 1 || nums[j] != nums[j - 1]) {
                        result = append(result, []int{nums[i], nums[j], nums[k]})
                    }
                    j++
                    k--
                }
            }
        }
    }
    return result
}
```